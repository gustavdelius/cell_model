---
title: "Comparing spectral method to finite-difference method"
author: "Gustav Delius"
date: "12 December 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Comparing spectral method to finite-difference method

In this document we are going to compare the accuracy of the spectral method
and the second-order finite-difference method in the example of the cell
model.

## Steady state solution
We use previously written code to calculate the analytic steady-state solution of the model and plot it in black in the following figure. We then introduce
a grid of $N=8$ points, equally spaced in log size, and represent the function
in terms of only its value at those discrete points. For values at intermediate
sizes we need to use an interpolation, and we plot in blue the trapezoidal
interpolation (underlying the second-order numerical integration scheme) and
in red the Fourier interpolation (underlying the spectral method).
```{r ss, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
source("lib.R")

# Set parameters ----
a <- 0.7; b <- 0.5; 
alpha <- 0.85; beta <- 1;
wa <- 0.7;  # threshold for duplication
delta <- 0.2  # width of offspring size distribution
wmin <- wa*(1-delta)/2  # Smallest possible cell size

N <- 1024  # Choose number of steps
x <- seq(log(wmin), 0, length.out = N+1)
w <- exp(x)

# Growth rate
g <- a*w^alpha-b*w^beta

# Division rate
# Use a k that stays finite but is large enough to ensure that
# almost all cells duplicate before reaching w=1
k <- 10000*(w-wa)^4
k[w<wa] <- 0

# Offspring size distribution
q <- function(w) {
    # Make q nonzero only between (1-delta)/2 and (1+delta)/2
    # Here we use a smooth bump function
    qr <- exp(-1/(1-(2/delta*(w-1/2))^2))/0.444*2/delta
    qr[abs(w-0.5)>=delta/2] <- 0  # Note that we need >= instead of just >
    # to avoid the singularity in the argument to the exponential
    
    return(qr)
}

# Calculate the steady-state solution ----
sol <- steady_state(t, w, g, k, wa, q, delta)
psi <- sol[[1]]
m <- sol[[2]]

# Plot the solution
par(mar=c(5,5,1,1))
plot(w, psi, type="l", lwd=3,
     xlab="w", ylab=expression(Psi(w)))

# small N ----
select8 <- seq(1, N+1, by=N/8)
p8 <- approx(w[select8], psi[select8], n=1025)
lines(p8, col="blue", lwd=2)

fp8 <- fourier_interpolate(psi[select8], 1025)
lines(w, fp8, col="red", lwd=2)
```

We see that the Fourier interpolation is better, which is even more
easily visible if we plot the difference between the actual solution and
the two interpolations.
```{r error, echo=FALSE, cache=TRUE}
plot(p8[[1]], approx(w, psi, n=1025)[[2]]-p8[[2]], col="blue", lwd=2, 
     type="l", xlab="w", ylab="Error")
lines(w, psi-fp8, col="red", lwd=2)
legend("bottom", c("finite-difference", "spectral method"),
       col=c("blue", "red"), lwd=2)
```

The important observation is that as the number of steps is increased,
the error decreases much faster for the spectral method than for the
finite-difference method. This can already be seen when we go to $N=32$
steps.
```{r error32, echo=FALSE}
select32 <- seq(1, N+1, by=N/32)
p32 <- approx(w[select32], psi[select32], n=1025)
fp32 <- fourier_interpolate(psi[select32], 1025)
plot(p32[[1]], approx(w, psi, n=1025)[[2]]-p32[[2]], col="blue", lwd=2, 
     type="l", xlab="w", ylab="Error")
lines(w, psi-fp32, col="red", lwd=2)
legend("bottom", c("finite-difference", "spectral method"),
       col=c("blue", "red"), lwd=2)
```

## Dynamics
Of course what really matters is not how well the different interpolations
agree with the exact steady-state. What matters is the errors that the
different methods produce when solving the cell model evolution equation. 

We use the code we had written earlier for solving the cell
model equation with the spectral method as well as a new variant of that function that uses a second-order
finite difference method, i.e., the trapezoidal method for the integrals and
the symmetric finite-difference for the first derivative.

```{r fd, echo=FALSE}
evolve_cell_pop_fd <- function(t, x, p0, g, k, q, m) {
    # Evolve cell population density with second-order finite-difference scheme
    #
    # Args:
    #   t: vector of times at which to return the population density
    #   x: vector of equally spaced steps in logarithmic cell size
    #      This should include both endpoints of the periodic interval.
    #      So length(x) is one larger than the number of steps
    #   p0 : vector on initial population density
    #   g: vector of growth rates
    #   k: vector of division rates
    #   q: function giving offspring size distribution
    #   m: death rate
    #
    # Value:
    #   matrix of population densities (columns t, rows x)
    N <- length(x)  # Number of x steps.
    dx <- x[2]-x[1]
    w <- exp(x)
    
    f <- function(t, p, parms) {
        
        linearPart <- -k*p-m*p
        
        birthPart <- rep_len(0, N)
        for (i in 1:N) {
            birthPart[i] <- 2*intx(k*p*q(w[i]/w)/w, w)[N-1]
        }
        
        gp <- c(0, g*p, 0)
        growthPart <- (gp[1:N]-gp[3:(N+2)])/(2*dx)/w
        
        return(list(linearPart + birthPart + growthPart))
    }
    out <- ode(y=p0, times=t, func=f)
    return(out[, -1])
}
```

The next figure shows the solution until time $t=10$ when starting with
an initial size distribution given by a Gaussian peak. We can see how
the peak cycles through the size range repeatedly while slowly approaching
the steady-state distribution. We are plotting also the $N=32$ finite-difference
approximation in blue and the $N=32$ spectral method approximation in red.
```{r sols, echo=FALSE, cache=TRUE}
tmax <- 50  # final time
Nt <- 500    # number of time steps at which to store intermediate values
t <- seq(0, tmax, by=tmax/Nt)

p0 <- 2*exp(-100*(w - 0.6)^2)

s <- seq(1, N+1, by=N/256)
pd256 <- evolve_cell_pop(t, x[s], p0[s], g=g[s], k=k[s], q=q(w[s]), m)

s <- seq(1, N+1, by=N/32)
pd32 <- evolve_cell_pop(t, x[s], p0[s], g=g[s], k=k[s], q=q(w[s]), m)
pp32 <- t(apply(pd32, 1, fourier_interpolate, 257))
sp <- seq(1, N+1, by=N/256)

pfd32 <- evolve_cell_pop_fd(t, x[s], p0[s], g=g[s], k=k[s], q, m)
ppfd32 <- t(apply(pfd32, 1, fourier_interpolate, 257))
```


```{r anim, fig.width=8, fig.height=5, fig.show='animate', interval=0.1, echo=FALSE, cache=TRUE}
for (T in 1:500) {
    plot(w[sp], pd256[T,], type="l", lwd=3, ylim=c(0,2), 
         xlab="w", ylab=expression(Psi(w)), main=paste("t =", T/10.0))
    lines(w[sp], pp32[T,], col="red", lwd=2)
    lines(w[sp], ppfd32[T,], col="blue", lwd=2)
    legend("topright", c("finite-difference", "spectral method"),
           col=c("blue", "red"), lwd=2)
}
```

We see that the errors from the finite-difference method quickly accummulate,
but then as the system approaches the steady-state, the errors disappear again.