library("rgl")
source("multi-species/steady_state.R")
source("multi-species/lib.R")
source("multi-species/params.R")

# Calculate the analytic steady-state solution ----
# This uses the expressions (4.16) to (4.21)
sol <- steady_state(r)
psi <- sol[[1]]
Nu <- sol[[2]]
if (length(psi) != r$N+1) {
    stop("psi has the wrong length.")
}

# make a matrix containing Ns steady-state distributions
psi = matrix(psi, nrow=r$N+1, ncol=r$Ns)

# Normalise psi so that the nutrient is at steady-state
# For this we observe that in eq.(2.12) the sigma is proportional to psi
# So we get \rho and \sigma to cancel by rescaling \psi -> psi * rho/sigma
# Alternatively see eqs.(5.33)-(5.35)
integral <- colSums(r$w^(alpha+1)*psi)*r$dx
psi <- psi * rho_0*(1-Nu/Nu_0) / (r$a(Nu)*sum(r$ws^(2-r$xi-r$gamma)*integral))

# Plot the single-species solution
par(mar=c(5,5,1,1))
plot(r$w, psi[,1], type="l", lwd=3,
     xlab="w", ylab=expression(Psi(w)))

# Solve equation ----

tmax <- 16  # final time
Nt <- 100    # number of time steps at which to store intermediate values
t <- seq(0, tmax, by=tmax/Nt)

#Our input p0 is a random pertubation of the solution
#generated by the code at the start
p0 <- psi#*(1+0.05*runif(Ns*(N+1)))
Nu0 <- Nu#*(1+0.05*runif(1))

# Some alternatives
#p0[ ,1] <- 5*exp(-100*(w - 0.6)^2)
#p0[ ,1] <- p0[(N+1):1,1]
#plot(w, p0[ ,1])

p <- evolve_cell_pop(t, p0, Nu0, r)
psit <- p[[1]]
Nut <- p[[2]]

persp3d(t, w, psit[,,1], col = "lightblue")
plot(t, Nut, type="l", ylab="N")

pcpt <- matrix(nrow = length(t), ncol = Na)
for (ti in 1:length(t)) {
    pcpt[ti,] <- community_spectrum(psit[ti,1:N,])
}
persp3d(t, xa, pcpt, col = "lightblue")
