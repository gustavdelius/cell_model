library("Matrix")
library("rgl")

source("lib.R")

# Set parameters ----
a <- 0.7; b <- 0.5; 
alpha <- 0.85; beta <- 1;
wa <- 0.7;  # threshold for duplication
delta <- 0.2  # width of offspring size distribution
wmin <- wa*(1-delta)/2  # Smallest possible cell size

N <- 256  # Choose number of steps
x <- seq(log(wmin), 0, length.out = N+1)
w <- exp(x)

# Growth rate
g <- a*w^alpha-b*w^beta

q <- function(w) {
    # Make q nonzero only between (1-delta)/2 and (1+delta)/2
    # Here we use a smooth bump function
    qr <- exp(-1/(1-(2/delta*(w-1/2))^2))/0.444*2/delta
    qr[abs(w-0.5)>=delta/2] <- 0  # Note that we need >= instead of just >
    # to avoid the singularity in the argument to the exponential
    
    # Use the following two lines if you want a step function
    # qr <- rep(0, length(w))
    # qr[abs(w-0.5)<delta/2] <- 1/delta
    
    return(qr)
}

# Use a k that stays finite but is large enough to ensure that
# almost all cells duplicate before reaching w=1
k <- 10000*(w-wa)^4
k[w<wa] <- 0

# Calculate the steady-state solution ----
sol <- steady_state(t, w, g, k, wa, q, delta)
psi <- sol[[1]]
m <- sol[[2]]

# Plot the solution
par(mar=c(5,5,1,1))
plot(w, psi, type="l", lwd=3,
     xlab="w", ylab=expression(Psi(w)))

# Solve equation ----

tmax <- 8  # final time
Nt <- 100    # number of time steps at which to store intermediate values
t <- seq(0, tmax, by=tmax/Nt)

#Our input p0 is a random pertubation of the solution
#generated by the code at the start
p0 <- psi[-1]+0.05*runif(N)

#psigauss=exp(-100*(x - 0.6)^2)

p <- evolve_cell_pop(t, x[-1], p0, g=g[-1], k=k[-1], q=q(w[-1]), m)

persp3d(t, w[-1], p, col = "lightblue")
