library("rgl")

source("lib.R")

M <- 1  # Number of species
N <- 32  # Number of steps

# Create grid
wa <- 0.7;  # threshold for duplication
delta <- 0.2  # width of offspring size distribution
#
wmin <- wa*(1-delta)/2  # Smallest possible cell size
x <- seq(log(wmin), 0, length.out = N+1)
w <- exp(x)  # vector of weights

# Nutrient dependent feeding coefficient in growth rate
a_inf <- 2; r <- 100;
#
a <- function(Nu) {
    a_inf*Nu/(r+Nu)
}

# Nutrient growth rate
rho_0 <- 100; Nu_0 <- 100;
#
rho <- function(Nu, psi) {
    integral <- intx(w^alpha*psi, w)
    rho_0*(1-Nu/Nu_0) - a(Nu)*integral[length(w)]
}

# Offspring size distribution
q <- function(w) {
    # Make q nonzero only between (1-delta)/2 and (1+delta)/2
    # Here we use a smooth bump function
    qr <- exp(-1/(1-(2/delta*(w-1/2))^2))/0.444*2/delta
    qr[abs(w-0.5)>=delta/2] <- 0  # Note that we need >= instead of just >
    # to avoid the singularity in the argument to the exponential
    qr
}

# Duplication rate
k_0 <- 10000  # scale
ke <- 4  # exponent
# Use a k that stays finite but is large enough to ensure that
# almost all cells duplicate before reaching w=1
k <- k_0*(w-wa)^ke
k[w<wa] <- 0

# We do not specify a death rate but determine it so that the
# steady-state occurs at a certain intake rate
abar <- 0.7
# This determine the steady-state value of Nu
Nu <- abar*r/(a_inf-abar)

# Cell growth rate
alpha <- 0.85; b <- 0.5; beta <- 1;
#
g <- function(w, Nu) {
    a(Nu)*w^alpha-b*w^beta
}
gv <- g(w, Nu)

# Calculate the steady-state solution ----
sol <- steady_state(t, w, gv, k, wa, q, delta)
psi <- sol[[1]]
m <- sol[[2]]

# Normalise psi so that the nutrient is at steady-state
integral <- intx(w^alpha*psi, w)
psi <- psi * rho_0*(1-Nu/Nu_0) / (a(Nu)*integral[length(w)])

# Plot the solution
par(mar=c(5,5,1,1))
plot(w, psi, type="l", lwd=3,
     xlab="w", ylab=expression(Psi(w)))

# Solve equation ----

tmax <- 8  # final time
Nt <- 100    # number of time steps at which to store intermediate values
t <- seq(0, tmax, by=tmax/Nt)

#Our input p0 is a random pertubation of the solution
#generated by the code at the start
p0 <- psi*(1+0.05*runif(N+1))
Nu0 <- Nu*(1+0.05*runif(1))

p0=200*exp(-100*(w - 0.6)^2)
plot(w, p0)

p <- evolve_cell_pop(t, x, p0, Nu0, g, sigma, k=k, q=q(w), m, rho)

persp3d(t, w, p[,1:(N+1)], col = "lightblue")
plot(t, p[,N+2], type="l", ylab="N")
