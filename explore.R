library("rgl")

source("lib.R")

# Set parameters ----
# nutrient replenishment rate
rho_0 <- 100; Nu_0 <- 100; 
# cell growth rate
a_inf <- 2; b <- 0.5; r <- 100; 
alpha <- 0.85; beta <- 1;
# Duplication rate
wa <- 0.7;  # threshold for duplication
k_0 <- 10000  # scale
ke <- 4  # exponent
# Offspring size distribution
delta <- 0.2  # width of offspring size distribution
# We do not specify a death rate but determine it so that the
# steady-state occurs at a certain intake rate
abar <- 0.7
# This determine the steady-state value of Nu
Nu <- abar*r/(a_inf-abar)

wmin <- wa*(1-delta)/2  # Smallest possible cell size

N <- 256  # Choose number of steps
x <- seq(log(wmin), 0, length.out = N+1)
w <- exp(x)

# Nutrient dependent feeding coefficient in growth rate
a <- function(Nu) {
    a_inf*Nu/(r+Nu)
}

# Nutrient growth rate
rho <- function(Nu, psi) {
    integral <- intx(w^alpha*psi, w)
    rho_0*(1-Nu/Nu_0) - a(Nu)*integral[length(w)]
}

# Cell growth rate
g <- function(w, Nu) {
    a(Nu)*w^alpha-b*w^beta
}
gv <- g(w, Nu)

# Offspring size distribution
q <- function(w) {
    # Make q nonzero only between (1-delta)/2 and (1+delta)/2
    # Here we use a smooth bump function
    qr <- exp(-1/(1-(2/delta*(w-1/2))^2))/0.444*2/delta
    qr[abs(w-0.5)>=delta/2] <- 0  # Note that we need >= instead of just >
    # to avoid the singularity in the argument to the exponential
    qr
}

# Duplication rate
# Use a k that stays finite but is large enough to ensure that
# almost all cells duplicate before reaching w=1
k <- k_0*(w-wa)^ke
k[w<wa] <- 0

# Calculate the steady-state solution ----
sol <- steady_state(t, w, gv, k, wa, q, delta)
psi <- sol[[1]]
m <- sol[[2]]

# Normalise psi so that the nutrient is at steady-state
integral <- intx(w^alpha*psi, w)
psi <- psi * rho_0*(1-Nu/Nu_0) / (a(Nu)*integral[length(w)])

# Plot the solution
par(mar=c(5,5,1,1))
plot(w, psi, type="l", lwd=3,
     xlab="w", ylab=expression(Psi(w)))

# Solve equation ----

tmax <- 100  # final time
Nt <- 100    # number of time steps at which to store intermediate values
t <- seq(0, tmax, by=tmax/Nt)

#Our input p0 is a random pertubation of the solution
#generated by the code at the start
p0 <- psi*(1+0.05*runif(N+1))
Nu0 <- Nu*(1+0.05*runif(1))

p0=200*exp(-100*(w - 0.6)^2)
plot(w, p0)

p <- evolve_cell_pop(t, x, p0, Nu0, g, sigma, k=k, q=q(w), m, rho)

persp3d(t, w, p[,1:(N+1)], col = "lightblue")
plot(t, p[,N+2], type="l", ylab="N")
