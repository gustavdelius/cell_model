library("rgl")
source("lib.R")

# Select characteristic cell sizes
# ws denotes the maximum cell size
# xs denotes the log of the maximum cell size
# We space our species equidistant in log size
xs_min <- 0  # Smallest characteristic log cell size
M <- 3  # Number of species
delta_xs <- 0.5  # Spacing of species in log size
xs <- seq(xs_min, by=delta_xs, length.out=M)
ws <- exp(xs)

# Set exponents
xi <- 0.15
nu <- 0.85
gamma <- 1 + nu + xi

# Create cell size grid ----
wa <- 0.7;  # threshold for duplication
delta <- 0.2  # width of offspring size distribution
N <- 32  # Number of steps
#
wmin <- wa*(1-delta)/2  # Smallest possible cell size
x <- seq(log(wmin), 0, length.out = N+1)  # equal step sizes in log size
w <- exp(x)  # vector of weights

# Nutrient dependent feeding coefficient in growth rate ----
# See eq.(2.11)
a_inf <- 2; r <- 100;
#
a <- function(Nu) {
    a_inf*Nu/(r+Nu)
}

# Nutrient growth rate ----
# See eq.(2.12) and (2.13)
rho_0 <- 100; Nu_0 <- 100;
#
dNu <- function(Nu, psi) {
    # Args:
    #   Nu: Nutrient concentration
    #   psi: (N+1) x M matrix with each column the scaled population of one 
    #        species
    integral <- colSums(w^alpha*psi)
    rho_0*(1-Nu/Nu_0) - (a(Nu)*sum(ws^(1-xi-gamma)*integral))
}

# Offspring size distribution ----
# See eq.(2.9) for the definition of q
# Here we use a smooth bump function
q <- function(w) {
    qr <- exp(-1/(1-(2/delta*(w-1/2))^2))/0.444*2/delta
    # Make q nonzero only between (1-delta)/2 and (1+delta)/2
    qr[abs(w-0.5)>=delta/2] <- 0  
    # Note that we needed >= instead of just >
    # to avoid the singularity in the argument to the exponential
    qr
}

# Duplication rate ----
k_0 <- 10000  # scale
ke <- 4  # exponent
# Use a k that stays finite but is large enough to ensure that
# almost all cells duplicate before reaching w=1
k <- k_0*(w-wa)^ke
k[w<wa] <- 0

# Death rate ----
# We do not specify a death rate but determine it so that the
# steady-state occurs at a certain intake rate
abar <- 0.7
# This determine the steady-state value of Nu, by solving eq.(2.11) for N
Nu <- abar*r/(a_inf-abar)

# Cell growth rate ----
# See eq.(2.5)
alpha <- 0.85; b <- 0.5; beta <- 1;
#
g <- function(w, Nu) {
    a(Nu)*w^alpha-b*w^beta
}
gv <- g(w, Nu)

# Calculate the analytic steady-state solution ----
# This uses the expressions (4.16) to (4.21)
sol <- steady_state(t, w, gv, k, wa, q, delta)
psi <- sol[[1]]
m <- sol[[2]]  # mortality rate
if (length(psi) != N+1) {
    error("psi has the wrong length.")
}

# make a matrix containing M steady-state distributions
psi = matrix(psi, nrow=N+1, ncol=M)

# Normalise psi so that the nutrient is at steady-state
# For this we observe that in eq.(2.12) the sigma is proportional to psi
# So we get \rho and \sigma to cancel by rescaling \psi -> psi * rho/sigma
# Alternatively see eqs.(5.33)-(5.35)
integral <- colSums(w^alpha*psi)
psi <- psi * rho_0*(1-Nu/Nu_0) / (a(Nu)*sum(ws^(1-xi-gamma)*integral))

# Plot the single-species solution
par(mar=c(5,5,1,1))
plot(w, psi[,1], type="l", lwd=3,
     xlab="w", ylab=expression(Psi(w)))

# Solve equation ----

tmax <- 8  # final time
Nt <- 100    # number of time steps at which to store intermediate values
t <- seq(0, tmax, by=tmax/Nt)

#Our input p0 is a random pertubation of the solution
#generated by the code at the start
p0 <- psi*(1+0.05*runif(M*(N+1)))
Nu0 <- Nu*(1+0.05*runif(1))

# Some alternatives
#p0[ ,1] <- 5*exp(-100*(w - 0.6)^2)
p0[ ,1] <- p0[(N+1):1,1]
plot(w, p0[ ,1])

p <- evolve_cell_pop(t, x, p0, Nu0, g, k=k, q=q(w), m, dNu)
psit <- p[[1]]
Nut <- p[[2]]

persp3d(t, w, psit[,,1], col = "lightblue")
plot(t, Nut, type="l", ylab="N")
